{"objects": [{
  "version": "0", 
  "data": "/*\n * Default Candlepin rule set.\n */\n\n\n\nvar SOCKET_FACT=\"cpu.cpu_socket(s)\";\nvar RAM_FACT = \"memory.memtotal\";\n\nfunction entitlement_name_space() {\n    return Entitlement;\n}\n\nfunction consumer_delete_name_space() {\n    return ConsumerDelete;\n}\n\nfunction pool_name_space() {\n    return Pool;\n}\n\nfunction criteria_name_space() {\n    return PoolCriteria;\n}\n\nfunction export_name_space() {\n    return Export;\n}\n\nfunction compliance_name_space() {\n    return Compliance;\n}\n\nfunction unbind_name_space() {\n    return Unbind;\n}\n\n/* Utility functions */\nfunction contains(a, obj) {\n    for (var i = 0; i < a.length; i++) {\n        var result = a[i] == obj;\n        if (result) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction containsAll(a, b) {\n    for (var i = 0 ; i < b.length ; i++) {\n        if (!contains(a, b[i])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction getRelevantProvidedProducts(pool, products) {\n    var provided = [];\n\n    for (var i = 0 ; i < products.length ; i++) {\n        var product = products[i];\n        if (pool.provides(product.getId())) {\n            provided.push(product);\n        }\n    }\n\n    return provided;\n}\n\nfunction providesSameProducts(products1, products2) {\n    return containsAll(products1, products2) && containsAll(products2, products1);\n}\n\nfunction arrayToString(a) {\n    msg = \"[\";\n    for each (q in a) {\n        msg += q.getId() + \" \";\n    }\n    msg += \"]\";\n    return msg;\n}\n\n// Compute the set of all sets of combinations of elements in a.\nfunction powerSet(a, n) {\n    if (a.length == 0) {\n        return [];\n    }\n\n    var res = [];\n    for each (x in powerSet(a.slice(1), n)) {\n        if (x.length <= n) {\n            res.push(x);\n        }\n        if (x.length + 1 <= n) {\n            var z = x.slice(0);\n            z.push(a[0]);\n            res.push(z);\n        }\n    }\n    res.push([a[0]]);\n    return res;\n}\n\n\n// Check if the provided list of pools contains any duplicated products\n// We don't need to worry about checking multi-entitle allowed products,\n// as you can use as many of those as you want.\nfunction hasNoProductOverlap(combination) {\n    var seen_product_ids = [];\n    for each (pool_class in combination) {\n        var pool = pool_class[0];\n        var products = pool.products;\n        for (var i = 0 ; i < products.length ; i++) {\n            var product = products[i];\n            if (!contains(seen_product_ids, product.id)) {\n                seen_product_ids.push(product.id);\n            } else if (product.getAttribute(\"multi-entitlement\") != \"yes\") {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n//Check to see if a pool provides any products that are already compliant\nfunction hasNoInstalledOverlap(pool, compliance) {\n    var products = pool.products;\n    for (var i = 0 ; i < products.length ; i++) {\n        var product = products[i];\n        log.debug(\"installed overlap: \" + product.id);\n        if (product.getAttribute(\"multi-entitlement\") != \"yes\" &&\n            compliance.getCompliantProducts().containsKey(product.id)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction architectureMatches(product, consumer) {\n    // Non-system consumers without an architecture fact can pass this rule\n    // regardless what arch the product requires.\n    if (!consumer.hasFact(\"uname.machine\") && !consumer.getType().equals(\"system\")) {\n        return true;\n    }\n\n    var supportedArches = [];\n    var archString = product.getAttribute('arch');\n    if (archString != null) {\n        supportedArches = archString.toUpperCase().split(prodAttrSeparator);\n\n        supportedArches = new java.util.HashSet(java.util.Arrays.asList(supportedArches));\n\n        // If X86 is supported, add all variants to this list:\n        if (supportedArches.contains(\"X86\")) {\n           supportedArches.add(\"I386\");\n           supportedArches.add(\"I586\");\n           supportedArches.add(\"I686\");\n        }\n\n        if(!supportedArches.contains('ALL') &&\n           (!consumer.hasFact(\"uname.machine\")  ||\n            !supportedArches.contains(consumer.getFact('uname.machine').toUpperCase())\n            )\n          ){\n           return false;\n       }\n   }\n\n   return true;\n}\n\nfunction get_attribute_from_pool(pool, attributeName) {\n    // this can be either a ReadOnlyPool or a Pool, so deal with attributes as appropriate.\n    var attribute = pool.getProductAttribute(attributeName);\n    if (\"getValue\" in attribute) {\n        var value = attribute.getValue();\n    }\n    else {\n        var value = attribute;\n    }\n    return value\n}\n\n// get the number of sockets that each entitlement from a pool covers.\n// if sockets is set to 0 or is not set, it is considered to be unlimited.\nfunction get_pool_sockets(pool) {\n    if (pool.getProductAttribute(\"sockets\")) {\n        var sockets = get_attribute_from_pool(pool, \"sockets\");\n        if (sockets == 0) {\n            return Infinity;\n        }\n        else {\n            return parseInt(sockets);\n        }\n    }\n    else {\n        return Infinity;\n    }\n}\n\n// assumptions: number of pools consumed from is not considered, so we might not be taking from the smallest amount.\n// we only stack within the same pool_class. if you have stacks that provide different sets of products,\n// you won't be able to stack from them\n//\n// iterate over a pool class, and determine the quantity of entitlements needed\n// to satisfy any stacking on the pools in the class, for the given consumer\n//\n// If we find a pool that has no stacking requirements, just use that one\n// (as we'll only need a quantity of one)\n// otherwise, group the pools by stack id, then select the pools we wish to use\n// based on which grouping will come closest to fully stacking.\n//\n//\nfunction findStackingPools(pool_class, consumer, compliance) {\n    var consumer_sockets = 1;\n    if (consumer.hasFact(SOCKET_FACT)) {\n        consumer_sockets = consumer.getFact(SOCKET_FACT);\n     }\n\n    var stackToEntitledSockets = {};\n    var stackToPoolMap = {};\n    var notStackable = [];\n\n    // data for existing partial stacks\n    // we need a map of product id to stack id\n    // (to see if there is an existing stack for a product\n    // we can build upon, or a conflicting stack)\n    var productIdToStackId = {};\n    var partialStacks = compliance.getPartialStacks();\n\n    // going to assume one stack per product on the system\n    for each (stack_id in compliance.getPartialStacks().keySet().toArray()) {\n        var covered_sockets = 0;\n        for each (entitlement in partialStacks.get(stack_id).toArray()) {\n            covered_sockets += entitlement.getQuantity() * get_pool_sockets(entitlement.getPool());\n            productIdToStackId[entitlement.getPool().getProductId()] = stack_id;\n            for each (product in entitlement.getPool().getProvidedProducts().toArray()) {\n                productIdToStackId[product.getProductId()] = stack_id;\n            }\n        }\n        // we can start entitling from the partial stack\n        stackToEntitledSockets[stack_id] = covered_sockets;\n    }\n\n    for each (pool in pool_class) {\n        var quantity = 0;\n        // ignore any pools that clash with installed compliant products\n        if (!hasNoInstalledOverlap(pool, compliance)) {\n            log.debug(\"installed overlap found, skipping: \" + pool.getId());\n            continue;\n        }\n\n        if (pool.getProductAttribute(\"multi-entitlement\") && pool.getProductAttribute(\"stacking_id\")) {\n\n            // make sure there isn't a conflicting pool already on the system\n            var installed_stack_id;\n            var seen_stack_id = false;\n            var conflicting_stacks = false;\n            for each (product in pool.getProducts()) {\n                if (productIdToStackId.hasOwnProperty(product.id)) {\n                    var new_installed_stack_id = productIdToStackId[product.id];\n                    if (new_installed_stack_id != installed_stack_id) {\n                        // the first id will be different\n                        if (!seen_stack_id) {\n                            installed_stack_id = new_installed_stack_id;\n                            seen_stack_id = true;\n                        } else {\n                            conflicting_stacks = true;\n                        }\n                    }\n                }\n            }\n\n            // this pool provides 2 or more products that already have entitlements on the system,\n            // with multiple stack ids\n            if (conflicting_stacks) {\n                continue;\n            }\n\n            var stack_id = pool.getProductAttribute(\"stacking_id\");\n            // check if this pool matches the stack id of an existing partial stack\n            if (seen_stack_id && installed_stack_id != stack_id) {\n                continue;\n            }\n\n\n            if (!stackToPoolMap.hasOwnProperty(stack_id)) {\n                stackToPoolMap[stack_id] = new java.util.HashMap();\n\n                // we might already have the partial stack from compliance\n                if (!stackToEntitledSockets.hasOwnProperty(stack_id)) {\n                    stackToEntitledSockets[stack_id] = 0;\n                }\n            }\n\n            // if this stack is already done, no need to add more to it.\n            if (stackToEntitledSockets[stack_id] >= consumer_sockets) {\n                continue;\n            }\n\n            var product_sockets = 0;\n            var pool_sockets = get_pool_sockets(pool);\n\n            while (stackToEntitledSockets[stack_id] + product_sockets < consumer_sockets) {\n                product_sockets += pool_sockets;\n                quantity++;\n            }\n\n            // don't take more entitlements than are available!\n            if (quantity > pool.getMaxMembers() - pool.getCurrentMembers()) {\n                quantity = pool.getMaxMembers() - pool.getCurrentMembers();\n            }\n\n            stackToEntitledSockets[stack_id] += quantity * pool_sockets;\n\n            stackToPoolMap[stack_id].put(pool, quantity);\n        } else {\n            // not stackable, just take one.\n            notStackable.push(pool);\n        }\n\n    }\n\n    var found_pool = false;\n\n    var not_stacked_sockets = 0;\n    var not_stacked_pool_map = new java.util.HashMap();\n    // We have a not stackable pool.\n    if (notStackable.length > 0) {\n        for each (pool in notStackable) {\n            var covered_sockets = get_pool_sockets(pool);\n            if (covered_sockets > not_stacked_sockets) {\n                found_pool = true;\n                not_stacked_pool_map = new java.util.HashMap();\n                not_stacked_pool_map.put(pool, 1);\n                not_stacked_sockets = covered_sockets;\n            }\n        }\n    }\n\n    // if an unstacked pool can cover all our products, take that.\n    if (not_stacked_sockets >= consumer_sockets) {\n        return not_stacked_pool_map;\n    }\n\n    // loop over our potential stacks, and just take the first stack that covers all sockets.\n    // else take the stack that covers the most sockets.\n    var best_sockets = 0;\n    var best_stack;\n    for (stack_id in stackToPoolMap) {\n        found_pool = true;\n        if (stackToEntitledSockets[stack_id] >= consumer_sockets) {\n            return stackToPoolMap[stack_id];\n        }\n        else if (stackToEntitledSockets[stack_id] > best_sockets) {\n            best_stack = stack_id;\n            best_sockets = stackToEntitledSockets[stack_id];\n        }\n    }\n\n    // All possible pools may have overlapped with existing products\n    // so return nothing!\n    if (!found_pool) {\n        return new java.util.HashMap();\n    }\n\n    // we can't fully cover the product. either select the best non stacker, or the best stacker.\n    if (not_stacked_sockets >= best_sockets) {\n        return not_stacked_pool_map;\n    }\n    else {\n        return stackToPoolMap[best_stack];\n    }\n}\n\n\n// given 2 pools, select the best one. It is a assumed that the pools offer the\n// same selection of products.\n// returns true if pool1 is a better choice than pool2, else false\nfunction comparePools(pool1, pool2) {\n\n    // Prefer a virt_only pool over a regular pool, else fall through to the next rules.\n    // At this point virt_only pools will have already been filtered out by the pre rules\n    // for non virt machines.\n    if (pool1.getAttribute(\"virt_only\") == \"true\" && pool2.getAttribute(\"virt_only\") != \"true\") {\n        return true;\n    }\n    else if (pool2.getAttribute(\"virt_only\") == \"true\" && pool1.getAttribute(\"virt_only\") != \"true\") {\n        return false;\n    }\n\n    // If both virt_only, prefer one with host_requires, otherwise keep looking\n    // for a reason to pick one or the other. We know that the host must match\n    // as pools are filtered before even being passed to select best pools.\n    if (pool1.getAttribute(\"virt_only\") == \"true\" && pool2.getAttribute(\"virt_only\") == \"true\") {\n        if (pool1.getAttribute(\"requires_host\") != null && pool2.getAttribute(\"requires_host\") == null) {\n            return true;\n        }\n        if (pool2.getAttribute(\"requires_host\") != null && pool1.getAttribute(\"requires_host\") == null) {\n            return false;\n        }\n        // If neither condition is true, no preference...\n    }\n\n    // If two pools are still considered equal, select the pool that expires first\n    if (pool2.getEndDate().after(pool1.getEndDate())) {\n        return true;\n    }\n\n}\n\nfunction isLevelExempt (level, exemptList) {\n    for each (var exemptLevel in exemptList.toArray()) {\n        if (exemptLevel.equalsIgnoreCase(level)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nvar Entitlement = {\n\n    // defines mapping of product attributes to functions\n    // the format is: <function name>:<order number>:<attr1>:...:<attrn>, comma-separated ex.:\n    // func1:1:attr1:attr2:attr3, func2:2:attr3:attr4\n    attribute_mappings: function() {\n        return  \"architecture:1:arch,\" +\n            \"sockets:1:sockets,\" +\n            \"ram:1:ram,\" +\n            \"requires_consumer_type:1:requires_consumer_type,\" +\n            \"user_license:1:user_license,\" +\n            \"virt_only:1:virt_only,\" +\n            \"virt_limit:1:virt_limit,\" +\n            \"requires_host:1:requires_host\";\n    },\n\n    pre_virt_only: function() {\n        var virt_pool = 'true'.equalsIgnoreCase(attributes.get('virt_only'));\n        var guest = false;\n        if (consumer.hasFact('virt.is_guest')) {\n            guest = 'true'.equalsIgnoreCase(consumer.getFact('virt.is_guest'));\n        }\n\n        if (virt_pool && !guest) {\n            pre.addError(\"rulefailed.virt.only\");\n        }\n    },\n\n    pre_requires_host: function() {\n        // It shouldn't be possible to get a host restricted pool in hosted, but just in\n        // case, make sure it won't be enforced if we do.\n        if (!standalone) {\n            return;\n        }\n        if (!consumer.hasFact(\"virt.uuid\")) {\n            pre.addError(\"rulefailed.virt.only\");\n            return;\n        }\n        var hostConsumer = pre.getHostConsumer(consumer.getFact(\"virt.uuid\"));\n\n        if (hostConsumer == null || !hostConsumer.getUuid().equals(attributes.get('requires_host'))) {\n            pre.addError(\"virt.guest.host.does.not.match.pool.owner\");\n        }\n    },\n\n    post_user_license: function() {\n        if (!consumer.isManifest()) {\n            // Default to using the same product from the pool.\n            var productId = pool.getProductId();\n\n            // Check if the sub-pool should be for a different product:\n            if (attributes.containsKey(\"user_license_product\")) {\n                productId = attributes.get(\"user_license_product\");\n            }\n\n            // Create a sub-pool for this user\n            post.createUserRestrictedPool(productId, pool,\n                                          attributes.get(\"user_license\"));\n        }\n    },\n\n    pre_requires_consumer_type: function() {\n        if (!attributes.get(\"requires_consumer_type\").equals(consumer.getType()) &&\n                !consumer.getType().equals(\"uebercert\")) {\n            pre.addError(\"rulefailed.consumer.type.mismatch\");\n        }\n    },\n\n    pre_virt_limit: function() {\n    },\n\n    post_virt_limit: function() {\n        if (standalone) {\n            var productId = pool.getProductId();\n            var virt_limit = attributes.get(\"virt_limit\");\n            if ('unlimited'.equals(virt_limit)) {\n                post.createHostRestrictedPool(productId, pool, 'unlimited');\n            } else {\n                var virt_quantity = parseInt(virt_limit) * entitlement.getQuantity();\n                if (virt_quantity > 0) {\n                    post.createHostRestrictedPool(productId, pool,\n                            virt_quantity.toString());\n                }\n            }\n        }\n        else {\n            // if we are exporting we need to deal with the bonus pools\n            if (consumer.isManifest()) {\n                var virt_limit = attributes.get(\"virt_limit\");\n                if (!'unlimited'.equals(virt_limit)) {\n                    // if the bonus pool is not unlimited, then the bonus pool quantity\n                    //   needs to be adjusted based on the virt limit\n                    var virt_quantity = parseInt(virt_limit) * entitlement.getQuantity();\n                    if (virt_quantity > 0) {\n                        var pools = post.lookupBySubscriptionId(pool.getSubscriptionId());\n                        for (var idex = 0 ; idex < pools.size(); idex++ ) {\n                            var derivedPool = pools.get(idex);\n                            if (derivedPool.getAttributeValue(\"pool_derived\")) {\n                                derivedPool = post.updatePoolQuantity(derivedPool, -1 * virt_quantity);\n                            }\n                        }\n                    }\n                }\n                else {\n                    // if the bonus pool is unlimited, then the quantity needs to go to 0\n                    //   when the physical pool is exhausted completely by export.\n                    //   A quantity of 0 will block future binds, whereas -1 does not.\n                    if (pool.getQuantity() == pool.getExported()) {\n                        //getting all pools matching the sub id. Filtering out the 'parent'.\n                        var pools = post.lookupBySubscriptionId(pool.getSubscriptionId());\n                        for (var idex = 0 ; idex < pools.size(); idex++ ) {\n                            var derivedPool = pools.get(idex);\n                            if (derivedPool.getAttributeValue(\"pool_derived\")) {\n                                derivedPool = post.setPoolQuantity(derivedPool, 0);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    },\n\n    pre_architecture: function() {\n       if (!architectureMatches(product, consumer)) {\n         pre.addWarning(\"rulewarning.architecture.mismatch\");\n       }\n    },\n\n    post_architecture: function() {\n    },\n\n    pre_sockets: function() {\n        //usually, we assume socket count to be 1 if it is undef. However, we need to know if it's\n        //undef here in order to know to skip the socket comparison (per acarter/jomara)\n        if (consumer.hasFact(SOCKET_FACT) && !product.hasAttribute(\"stacking_id\")) {\n            if ((parseInt(product.getAttribute(\"sockets\")) > 0) &&\n                (parseInt(product.getAttribute(\"sockets\")) < parseInt(consumer.getFact(SOCKET_FACT)))) {\n                pre.addWarning(\"rulewarning.unsupported.number.of.sockets\");\n            }\n        }\n    },\n\n    post_sockets: function() {\n    },\n\n    pre_ram: function() {\n        var consumerRam = get_consumer_ram(consumer);\n        log.debug(\"Consumer has \" + consumerRam + \"GB of RAM.\");\n\n        var productRam = parseInt(product.getAttribute(\"ram\"));\n        log.debug(\"Product has \" + productRam + \"GB of RAM\");\n        if (consumerRam > productRam) {\n            pre.addWarning(\"rulewarning.unsupported.ram\");\n        }\n    },\n\n    post_ram: function() {\n    },\n\n    pre_global: function() {\n        if (!consumer.isManifest()) {\n            if (consumer.hasEntitlement(pool.getId()) && product.getAttribute(\"multi-entitlement\") != \"yes\") {\n                pre.addError(\"rulefailed.consumer.already.has.product\");\n            }\n\n            if (pre.getQuantity() > 1 && product.getAttribute(\"multi-entitlement\") != \"yes\") {\n                pre.addError(\"rulefailed.pool.does.not.support.multi-entitlement\");\n            }\n\n            // If the product has no required consumer type, assume it is restricted to \"system\".\n            // \"hypervisor\"/\"uebercert\" type are essentially the same as \"system\".\n            if (!product.hasAttribute(\"requires_consumer_type\")) {\n                if (!consumer.getType().equals(\"system\") && !consumer.getType().equals(\"hypervisor\") &&\n                        !consumer.getType().equals(\"uebercert\")) {\n                    pre.addError(\"rulefailed.consumer.type.mismatch\");\n                }\n\n            }\n\n            if (pool.getRestrictedToUsername() != null && !pool.getRestrictedToUsername().equals(consumer.getUsername())) {\n                pre.addError(\"pool.not.available.to.user, pool= '\" + pool.getRestrictedToUsername() + \"', actual username='\" + consumer.getUsername() + \"'\" );\n            }\n        }\n\n        // Manifest consumers should not be able to find to any derived pools. Because\n        // they are exempt from all pre-rules, to keep these derived pools out of the list\n        // they can bind to we must use pre_global, which is used for manifest consumers.\n        else {\n            if (pool.getAttributes().containsKey(\"pool_derived\")) {\n                pre.addError(\"pool.not.available.to.manifest.consumers\");\n            }\n        }\n\n        // FIXME\n        // for auto sub stacking, we need to be able to pull across multiple\n        // pools eventually, so this would need to go away in that case\n        pre.checkQuantity(pool);\n    },\n\n    post_global: function() {\n    },\n\n    select_pool_global: function() {\n        // Greedy selection for now, in order\n        // XXX need to watch out for multientitle products - how so?\n\n        // An array of arrays of pools. each array is a grouping of pools that provide the\n        // same subset of products which are applicable to the requested products.\n        // further, each array is sorted, from best to worst. (pool fitness is determined\n        // arbitrarily by rules herein.\n        var pools_by_class = [];\n\n        // \"pools\" is a list of all the owner's pools which are compatible for the system:\n        if (log.isDebugEnabled()) {\n            log.debug(\"Selecting best pools from: \" + pools.length);\n            for each (pool in pools) {\n                log.debug(\"   \" + pool.getId());\n            }\n        }\n\n        var consumerSLA = consumer.getServiceLevel();\n        if (consumerSLA && !consumerSLA.equals(\"\")) {\n            log.debug(\"Filtering pools by SLA: \" + consumerSLA);\n        }\n\n        // Builds out the pools_by_class by iterating each pool, checking which products it provides (that\n        // are relevant to this request), then filtering out other pools which provide the *exact* same products\n        // by selecting the preferred pool based on other criteria.\n        for (var i = 0 ; i < pools.length ; i++) {\n            var pool = pools[i];\n\n            // If the SLA of the consumer does not match that of the pool\n            // we do not consider the pool unless the level is exempt\n            var poolSLA = pool.getProductAttribute('support_level');\n            var poolSLAExempt = isLevelExempt(pool.getProductAttribute('support_level'), exemptList);\n\n            if (!poolSLAExempt && consumerSLA &&\n                !consumerSLA.equals(\"\") && !consumerSLA.equalsIgnoreCase(poolSLA)) {\n                log.debug(\"Skipping pool \" + pool.getId() +\n                        \" since SLA does not match that of the consumer.\");\n                continue;\n            }\n\n            log.debug(\"Checking pool for best unique provides combination: \" +\n                    pool.getId());\n            log.debug(\"  top level product: \" + (pool.getTopLevelProduct().getId()));\n            if (architectureMatches(pool.getTopLevelProduct(), consumer)) {\n                var provided_products = getRelevantProvidedProducts(pool, products);\n                log.debug(\"  relevant provided products: \");\n                for each (pp in provided_products) {\n                    log.debug(\"    \" + pp.getId());\n                }\n                // XXX wasteful, should be a hash or something.\n                // Tracks if we found another pool previously looked at which had the exact same provided products:\n                var duplicate_found = false;\n\n                // Check current pool against previous best to see if it's better:\n                for each (pool_class in pools_by_class) {\n                    var best_pool = pool_class[0];\n                    var best_provided_products = getRelevantProvidedProducts(best_pool, products);\n\n                    if (providesSameProducts(provided_products, best_provided_products)) {\n                        duplicate_found = true;\n                        log.debug(\"  provides same product combo as: \" + pool.getId());\n\n                        // figure out where to insert this pool in its sorted class\n                        var i = 0;\n                        for (; i < pool_class.length; i++) {\n                            if (comparePools(pool, best_pool)) {\n                                break;\n                            }\n                        }\n\n                        // now insert the pool into the middle of the array\n                        pool_class.splice(i, 0, pool);\n                        break;\n                    }\n                }\n\n                // If we did not find a duplicate pool providing the same products,\n                if (!duplicate_found) {\n                    var pool_class = [];\n                    pool_class.push(pool);\n                    pools_by_class.push(pool_class);\n                }\n            }\n        }\n\n        var candidate_combos = powerSet(pools_by_class, products.length);\n\n        log.debug(\"Selecting \" + products.length + \" products from \" + pools_by_class.length +\n                  \" pools in \" + candidate_combos.length + \" possible combinations\");\n\n        // Select the best pool combo. We prefer:\n        // -The combo that provides the most products\n        // -The combo that uses the fewest entitlements\n\n\n        var selected_pools = new java.util.HashMap();\n        var best_provided_count = 0;\n        var best_entitlements_count = 0;\n\n        for each (pool_combo in candidate_combos) {\n            var provided_count = 0;\n            var unique_provided = [];\n            for each (pool_class in pool_combo) {\n                var pool = pool_class[0];\n                var provided_products = getRelevantProvidedProducts(pool, products);\n                for each (provided_product in provided_products) {\n                    log.debug(\"\\t\\tprovided_product \" + provided_product.getId());\n                    if (!contains(unique_provided, provided_product)) {\n                        unique_provided.push(provided_product);\n                    }\n                }\n            }\n\n            for each (product in unique_provided){\n                log.debug(\"unique_provided \" + product.getId() + \" \" + product.getName());\n            }\n\n            // number of provided products is less than our best selection. keep our current selection.\n            if (unique_provided.length < best_provided_count) {\n                continue;\n            }\n\n            // we do it after the unique provided.length check because that value is the best we can do\n            // create 'best' stacking combo here\n            // use that best combo for the following comparison\n\n            if (unique_provided.length > best_provided_count || pool_combo.length < best_entitlements_count) {\n                // XXX we'll have to do something here to ensure no product overlap after selecting the actual pool/pools from the combo\n                if (hasNoProductOverlap(pool_combo)) {\n                    var new_selection = new java.util.HashMap();\n                    var total_entitlements = 0;\n                    for each (pool_class in pool_combo) {\n                        var poolMap = findStackingPools(pool_class, consumer, compliance);\n                        new_selection.putAll(poolMap);\n\n                        var quantity = 0;\n                        for (value in poolMap.values()) {\n                            quantity += value;\n                        }\n\n                        total_entitlements += quantity;\n                    }\n\n                    // now verify that after selecting our actual pools from the pool combo,\n                    // we still have a better choice here\n                    if (new_selection.size() > 0) {\n                        selected_pools = new_selection;\n                        best_provided_count = unique_provided.length;\n                        best_entitlements_count = total_entitlements;\n                    }\n                }\n            }\n        }\n\n        for (pool in selected_pools.keySet()){\n            log.debug(\"selected_pool2 \" + pool);\n        }\n\n        // We may not have selected pools for all products; that's ok.\n        return selected_pools;\n    }\n}\n\nvar ConsumerDelete = {\n    global: function() {\n        if (consumer.getType() == \"person\") {\n            helper.deleteUserRestrictedPools(consumer.getUsername());\n        }\n    }\n}\n\n/*\n * Return Hibernate criteria we can apply to the pool query when listing pools that\n * are relevant for a consumer.\n */\nvar PoolCriteria = {\n    poolCriteria: function() {\n        // FIXME: alot of this could be cleaned up with some\n        // class/method var's instead of full paths, etc\n        var criteriaFilters = new java.util.LinkedList();\n        // Don't load virt_only pools if this consumer isn't a guest:\n        if (!\"true\".equalsIgnoreCase(consumer.getFact(\"virt.is_guest\"))) {\n            // not a guest\n            var noVirtOnlyPoolAttr =\n                org.hibernate.criterion.DetachedCriteria.forClass(\n                        org.candlepin.model.PoolAttribute, \"pool_attr\")\n                    .add(org.hibernate.criterion.Restrictions.eq(\"name\", \"virt_only\"))\n                    .add(org.hibernate.criterion.Restrictions.eq(\"value\", \"true\"))\n                    .add(org.hibernate.criterion.Property.forName(\"this.id\")\n                            .eqProperty(\"pool_attr.pool.id\"))\n                    .setProjection(org.hibernate.criterion.Projections.property(\"pool_attr.id\"));\n            criteriaFilters.add(org.hibernate.criterion.Subqueries.notExists(\n                    noVirtOnlyPoolAttr));\n\n            // same criteria but for PoolProduct attributes\n            // not sure if this should be two seperate criteria, or if it's\n            // worth it to combine in some clever fashion\n            var noVirtOnlyProductAttr =\n                org.hibernate.criterion.DetachedCriteria.forClass(\n                        org.candlepin.model.ProductPoolAttribute, \"prod_attr\")\n                    .add(org.hibernate.criterion.Restrictions.eq(\"name\", \"virt_only\"))\n                    .add(org.hibernate.criterion.Restrictions.eq(\"value\", \"true\"))\n                    .add(org.hibernate.criterion.Property.forName(\"this.id\")\n                            .eqProperty(\"prod_attr.pool.id\"))\n                    .setProjection(org.hibernate.criterion.Projections.property(\"prod_attr.id\"));\n            criteriaFilters.add(org.hibernate.criterion.Subqueries.notExists(\n                    noVirtOnlyProductAttr));\n\n        } else {\n            // we are a virt guest\n            // add criteria for filtering out pools that are not for this guest\n            if (consumer.hasFact(\"virt.uuid\")) {\n                var hostUuid = \"\"; // need a default value in case there is no registered host\n                if (hostConsumer != null) {\n                    hostUuid = hostConsumer.getUuid();\n                }\n                var noRequiresHost = org.hibernate.criterion.DetachedCriteria.forClass(\n                        org.candlepin.model.PoolAttribute, \"attr\")\n                        .add(org.hibernate.criterion.Restrictions.eq(\"name\", \"requires_host\"))\n                        //  Note: looking for pools that are not for this guest\n                        .add(org.hibernate.criterion.Restrictions.ne(\"value\", hostUuid))\n                        .add(org.hibernate.criterion.Property.forName(\"this.id\")\n                                .eqProperty(\"attr.pool.id\"))\n                                .setProjection(org.hibernate.criterion.Projections.property(\"attr.id\"));\n                // we do want everything else\n                criteriaFilters.add(org.hibernate.criterion.Subqueries.notExists(\n                        noRequiresHost));\n            }\n            // no virt.uuid, we can't try to filter\n        }\n\n        return criteriaFilters;\n    }\n}\n\n\nvar Pool = {\n\n    /*\n     * Creates all appropriate pools for a subscription.\n     */\n    createPools: function () {\n        var pools = new java.util.LinkedList();\n        var quantity = sub.getQuantity() * sub.getProduct().getMultiplier();\n        var providedProducts = new java.util.HashSet();\n        var newPool = new org.candlepin.model.Pool(sub.getOwner(), sub.getProduct().getId(),\n                sub.getProduct().getName(), providedProducts,\n                    quantity, sub.getStartDate(), sub.getEndDate(), sub.getContractNumber(),\n                    sub.getAccountNumber());\n        if (sub.getProvidedProducts() != null) {\n            for each (var p in sub.getProvidedProducts().toArray()) {\n                var providedProduct = new org.candlepin.model.\n                    ProvidedProduct(p.getId(), p.getName());\n                providedProduct.setPool(newPool);\n                providedProducts.add(providedProduct);\n            }\n        }\n        helper.copyProductAttributesOntoPool(sub, newPool);\n        newPool.setSubscriptionId(sub.getId());\n        newPool.setSubscriptionSubKey(\"master\");\n        var virtAtt = sub.getProduct().getAttribute(\"virt_only\");\n\n        // note: the product attributes are getting copied above, but the following will make\n        //   virt_only a pool attribute. That makes the pool explicitly virt_only to subscription\n        //    manager and any other downstream comsumer.\n        if (virtAtt != null && virtAtt.getValue() != null &&\n            !virtAtt.getValue().equals(\"\")) {\n            newPool.addAttribute(new org.candlepin.model.PoolAttribute(\"virt_only\", virtAtt.getValue()));\n        }\n\n        pools.add(newPool);\n\n        // Check if we need to create a virt-only pool for this subscription:\n        if (attributes.containsKey(\"virt_limit\") && !standalone) {\n            var virt_limit = attributes.get(\"virt_limit\");\n            var virt_attributes = new java.util.HashMap();\n            virt_attributes.put(\"virt_only\", \"true\");\n            virt_attributes.put(\"pool_derived\", \"true\");\n            // Make sure the virt pool does not have a virt_limit,\n            // otherwise this will recurse infinitely\n            virt_attributes.put(\"virt_limit\", \"0\");\n\n            if ('unlimited'.equals(virt_limit)) {\n                var derivedPool = helper.createPool(sub, sub.getProduct().getId(),\n                                                    'unlimited', virt_attributes);\n                derivedPool.setSubscriptionSubKey(\"derived\");\n                pools.add(derivedPool);\n            } else {\n                var virt_limit_quantity = parseInt(virt_limit);\n\n                if (virt_limit_quantity > 0) {\n                    var virt_quantity = quantity * virt_limit_quantity;\n\n                    var derivedPool = helper.createPool(sub, sub.getProduct().getId(),\n                                                        virt_quantity.toString(),\n                                                        virt_attributes);\n                    derivedPool.setSubscriptionSubKey(\"derived\");\n                    pools.add(derivedPool);\n                }\n            }\n        }\n        return pools;\n    },\n\n    /*\n     * Updates the existing pools for a subscription.\n     */\n    updatePools: function () {\n        var poolsUpdated = new java.util.LinkedList();\n        for each (var existingPool in pools.toArray()) {\n            var datesChanged = (!sub.getStartDate().equals(\n                existingPool.getStartDate())) ||\n                (!sub.getEndDate().equals(existingPool.getEndDate()));\n            // Expected quantity is normally the subscription's quantity, but for\n            // virt only pools we expect it to be sub quantity * virt_limit:\n            var expectedQuantity = sub.getQuantity() * sub.getProduct().getMultiplier();\n\n            /*\n             *  WARNING: when updating pools, we have the added complication of having to\n             *  watch out for pools that candlepin creates internally. (i.e. virt bonus\n             *  pools in hosted (created when sub is first detected), and host restricted\n             *  virt pools when on-site. (created when a host binds)\n             */\n            if (existingPool.hasAttribute(\"pool_derived\") &&\n                existingPool.attributeEquals(\"virt_only\", \"true\") &&\n                existingPool.hasProductAttribute(\"virt_limit\")) {\n\n                if (!attributes.containsKey(\"virt_limit\")) {\n                    log.warn(\"virt_limit attribute has been removed from subscription, flagging pool for deletion if supported: \" + existingPool.getId());\n                    // virt_limit has been removed! We need to clean up this pool. Set\n                    // attribute to notify the server of this:\n                    existingPool.setAttribute(\"candlepin.delete_pool\", \"true\");\n                    // Older candlepin's won't look at the delete attribute, so we will\n                    // set the expected quantity to 0 to effectively disable the pool\n                    // on those servers as well.\n                    expectedQuantity = 0;\n                }\n                else {\n                    var virt_limit = attributes.get(\"virt_limit\");\n\n                    if ('unlimited'.equals(virt_limit)) {\n                        if (existingPool.getQuantity() == 0) {\n                            // this will only happen if the rules set it to be 0.\n                            //   don't modify\n                            expectedQuantity = 0;\n                        }\n                        else {\n                            // pretty much all the rest.\n                            expectedQuantity = -1;\n                        }\n                    }\n                    else {\n                        if (standalone) {\n                            // this is how we determined the quantity\n                            expectedQuantity = existingPool.getSourceEntitlement().getQuantity() * parseInt(virt_limit);\n                        }\n                        else {\n                            // we need to see if a parent pool exists and has been exported. Adjust is number exported\n                            //   from a parent pool. If no parent pool, adjust = 0 [a scenario of virtual pool only]\n                            // WARNING: we're assuming there is only one base (non-derived) pool. This may change in the\n                            // future requiring a more complex adjustment for exported quantities if there are multiple\n                            // pools in play.\n                            var adjust = 0;\n                            for (var idex = 0 ; idex < pools.size(); idex++ ) {\n                                var derivedPool = pools.get(idex);\n                                if (!derivedPool.getAttributeValue(\"pool_derived\")) {\n                                    adjust = derivedPool.getExported();\n                                }\n                            }\n                            expectedQuantity = (expectedQuantity-adjust) * parseInt(virt_limit);\n                        }\n                    }\n                }\n            }\n\n            var quantityChanged = !(expectedQuantity == existingPool.getQuantity());\n            var productsChanged = helper.checkForChangedProducts(existingPool, sub);\n\n            var productAttributesChanged = helper.copyProductAttributesOntoPool(sub,\n                                                                             existingPool);\n            if (productAttributesChanged) {\n                log.info(\"Updated product attributes from subscription.\");\n            }\n\n            if (!(quantityChanged || datesChanged || productsChanged ||\n                  productAttributesChanged)) {\n                //TODO: Should we check whether pool is overflowing here?\n                continue;\n            }\n\n            if (quantityChanged) {\n                log.info(\"   Quantity changed to: \" + expectedQuantity);\n                existingPool.setQuantity(expectedQuantity);\n            }\n\n            if (datesChanged) {\n                log.info(\"   Subscription dates changed.\");\n                existingPool.setStartDate(sub.getStartDate());\n                existingPool.setEndDate(sub.getEndDate());\n            }\n\n            if (productsChanged) {\n                log.info(\"   Subscription products changed.\");\n                existingPool.setProductName(sub.getProduct().getName());\n                existingPool.setProductId(sub.getProduct().getId());\n                existingPool.getProvidedProducts().clear();\n\n                if (sub.getProvidedProducts() != null) {\n                    for each (var p in sub.getProvidedProducts().toArray()) {\n                        var providedProduct = new org.candlepin.model.\n                            ProvidedProduct(p.getId(), p.getName());\n                        existingPool.addProvidedProduct(providedProduct);\n                    }\n                }\n            }\n            poolsUpdated.add(new org.candlepin.policy.js.pool.PoolUpdate(\n                                 existingPool, datesChanged, quantityChanged, productsChanged));\n        }\n        return poolsUpdated;\n    }\n\n}\n\nvar Export = {\n    can_export_entitlement: function() {\n        pool_derived = attributes.containsKey('pool_derived');\n        return !consumer.isManifest() || !pool_derived;\n    }\n}\n\nfunction is_stacked(ent) {\n    return ent.getPool().hasProductAttribute(\"stacking_id\");\n}\n\n/**\n * Check the given list of entitlements to see if a stack ID is compliant for\n * a consumer's socket count.\n */\nfunction stack_is_compliant(consumer, stack_id, ents, log) {\n    log.debug(\"Checking stack compliance for: \" + stack_id);\n    var consumer_sockets = 1;\n    if (consumer.hasFact(SOCKET_FACT)) {\n        consumer_sockets = parseInt(consumer.getFact(SOCKET_FACT));\n    }\n    log.debug(\"Consumer sockets: \" + consumer_sockets);\n\n    var covered_sockets = 0;\n    for each (var ent in ents.toArray()) {\n        if (is_stacked(ent)) {\n            var currentStackId = ent.getPool().getProductAttribute(\"stacking_id\").getValue();\n            if (currentStackId.equals(stack_id)) {\n                covered_sockets += get_pool_sockets(ent.getPool()) * ent.getQuantity();\n                log.debug(\"Ent \" + ent.getId() + \" took covered sockets to: \" + covered_sockets);\n            }\n        }\n    }\n\n    return covered_sockets >= consumer_sockets;\n}\n\n/*\n * Check an entitlement to see if it provides sufficent CPU sockets a consumer.\n */\nfunction ent_is_compliant(consumer, ent, log) {\n    log.debug(\"Checking entitlement compliance: \" + ent.getId());\n    var consumerSockets = 1;\n    if (consumer.hasFact(SOCKET_FACT)) {\n        consumerSockets = parseInt(consumer.getFact(SOCKET_FACT));\n    }\n    log.debug(\"  Consumer sockets found: \" + consumerSockets);\n\n    var coveredSockets = get_pool_sockets(ent.getPool());\n    log.debug(\"  Sockets covered by pool: \" + coveredSockets);\n\n    if (coveredSockets < consumerSockets) {\n        log.debug(\"  Entitlement does not cover system sockets.\");\n        return false;\n    }\n\n    // Verify RAM coverage if required.\n    // Default consumer RAM to 1 GB if not defined\n    var consumerRam = get_consumer_ram(consumer);\n    log.debug(\"  Consumer RAM found: \" + consumerRam);\n\n    if (ent.getPool().getProductAttribute(\"ram\")) {\n        var poolRamAttr = get_attribute_from_pool(ent.getPool(), \"ram\");\n        if (poolRamAttr != null && !poolRamAttr.isEmpty()) {\n            var ram = parseInt(poolRamAttr);\n            log.debug(\"  Pool RAM found: \" + ram)\n            if (consumerRam > ram) {\n                return false;\n            }\n        }\n    }\n    else {\n        log.debug(\"  No RAM attribute on pool. Skipping RAM check.\");\n    }\n\n    return true\n}\n\nfunction get_consumer_ram(consumer) {\n    var consumerRam = 1;\n    if (consumer.hasFact(RAM_FACT)) {\n        var ramGb = parseInt(consumer.getFact(RAM_FACT)) / 1024 / 1024;\n        consumerRam = java.lang.Math.round(ramGb);\n    }\n    return consumerRam;\n}\n\n/**\n * Returns an array of product IDs the entitlement provides which are relevant\n * (installed) on the given consumer.\n */\nfunction find_relevant_pids(entitlement, consumer) {\n    provided_pids = [];\n    if (consumer.getInstalledProducts() == null) {\n        return provided_pids;\n    }\n    for each (var installed_prod in consumer.getInstalledProducts().toArray()) {\n        var installed_pid = installed_prod.getProductId();\n        if (entitlement.getPool().provides(installed_pid) == true) {\n            log.debug(\"pool provides: \" + installed_pid);\n            provided_pids.push(installed_pid);\n        }\n    }\n    return provided_pids;\n}\n\nvar Compliance = {\n    get_status: function() {\n        var status = getComplianceStatusOnDate(consumer, entitlements, ondate, log);\n        var compliantUntil = ondate;\n        if (status.isCompliant()) {\n            if (entitlements.isEmpty()) {\n                compliantUntil = null;\n            }\n            else {\n                compliantUntil = determineCompliantUntilDate(consumer, ondate, helper, log);\n            }\n        }\n        status.setCompliantUntil(compliantUntil);\n        return status;\n    },\n\n    is_stack_compliant: function() {\n        return stack_is_compliant(consumer, stack_id, entitlements, log);\n    },\n\n    is_ent_compliant: function () {\n        return ent_is_compliant(consumer, ent, log);\n    }\n}\n\n/**\n * Checks compliance status for a consumer on a given date.\n */\nfunction getComplianceStatusOnDate(consumer, entitlements, ondate, log) {\n    var status = new org.candlepin.policy.js.compliance.ComplianceStatus(ondate);\n\n    // Track the stack IDs we've already checked to save some time:\n    var compliant_stack_ids = new java.util.HashSet();\n    var non_compliant_stack_ids = new java.util.HashSet();\n\n    log.debug(\"Checking compliance status for consumer: \" + consumer.getUuid());\n    for each (var e in entitlements.toArray()) {\n        log.debug(\"  checking entitlement: \" + e.getId());\n        relevant_pids = find_relevant_pids(e, consumer);\n        log.debug(\"    relevant products: \" + relevant_pids);\n\n        partially_stacked = false;\n        var ent_is_stacked = is_stacked(e);\n        // If the pool is stacked, check that the stack requirements are met:\n        if (ent_is_stacked) {\n            var stack_id = e.getPool().getProductAttribute(\"stacking_id\").getValue();\n            log.debug(\"    pool has stack ID: \" + stack_id);\n\n            // Shortcuts for stacks we've already checked:\n            if (non_compliant_stack_ids.contains(stack_id) > 0) {\n                log.debug(\"    stack already found to be non-compliant\");\n                partially_stacked = true;\n                status.addPartialStack(stack_id, e);\n            }\n            else if (compliant_stack_ids.contains(stack_id) > 0) {\n                log.debug(\"    stack already found to be compliant\");\n            }\n            // Otherwise check the stack and add appropriately:\n            else if(!stack_is_compliant(consumer, stack_id, entitlements, log)) {\n                log.debug(\"    stack is non-compliant\");\n                partially_stacked = true;\n                status.addPartialStack(stack_id, e);\n                non_compliant_stack_ids.add(stack_id);\n            }\n            else {\n                log.debug(\"    stack is compliant\");\n                compliant_stack_ids.add(stack_id);\n            }\n        }\n\n        for each (relevant_pid in relevant_pids) {\n            if (partially_stacked) {\n                log.debug(\"   partially compliant: \" + relevant_pid);\n                status.addPartiallyCompliantProduct(relevant_pid, e);\n            }\n            else if (!ent_is_compliant(consumer, e, log) && !ent_is_stacked) {\n                log.debug(\"    partially compliant (non-stacked): \" + relevant_pid);\n                status.addPartiallyCompliantProduct(relevant_pid, e);\n            }\n            else  {\n                log.debug(\"    fully compliant: \" + relevant_pid);\n                status.addCompliantProduct(relevant_pid, e);\n            }\n        }\n    }\n\n    // Run through each partially compliant product, if we also found a\n    // regular entitlement which provides that product, then it should not be\n    // considered partially compliant as well. We do however still leavecomplianceRules.getStatus(consumer, next); the *stack*\n    // in partial stacks list, as this should be repaired. (it could offer other\n    // products)\n    for each (var partial_prod in status.getPartiallyCompliantProducts().keySet().toArray()) {\n        if (status.getCompliantProducts().keySet().contains(partial_prod)) {\n            status.getPartiallyCompliantProducts().remove(partial_prod);\n        }\n    }\n\n    // Run through the consumer's installed products and see if there are any we\n    // didn't find an entitlement for along the way:\n    if (consumer.getInstalledProducts() != null) {\n        for each (var installed_prod in consumer.getInstalledProducts().toArray()) {\n            var installed_pid = installed_prod.getProductId();\n            // Not compliant if we didn't find any entitlements for this product:\n            if (!status.getCompliantProducts().containsKey(installed_pid) &&\n                    !status.getPartiallyCompliantProducts().containsKey(installed_pid)) {\n                status.addNonCompliantProduct(installed_pid);\n            }\n        }\n    }\n    return status;\n}\n\n/**\n * Determine the compliant until date for a consumer based on the specifed start date\n * and entitlements.\n */\nfunction determineCompliantUntilDate(consumer, startDate, complianceHelper, log) {\n    var initialEntitlements = complianceHelper.getEntitlementsOnDate(consumer, startDate);\n    // Get all end dates from current entitlements sorted ascending.\n    var dates = complianceHelper.getSortedEndDatesFromEntitlements(initialEntitlements)\n        .toArray();\n\n    for each (var dateToCheck in dates) {\n        var next = new Date(dateToCheck.getTime());\n        var jsStartDate = new Date(startDate.getTime());\n\n        // Ignore past dates.\n        if (next < jsStartDate) {\n            continue;\n        }\n        // Need to check if we are still compliant after the end date,\n        // so we add one second.\n        next.setSeconds(next.getSeconds() + 1);\n\n        var entitlementsOnDate = complianceHelper.getEntitlementsOnDate(consumer,\n                next);\n        var status = getComplianceStatusOnDate(consumer, entitlementsOnDate, next, log);\n        if (!status.isCompliant()) {\n        return next;\n        }\n    }\n    return null;\n}\n\nvar Unbind = {\n\n    // defines mapping of product attributes to functions\n    // the format is: <function name>:<order number>:<attr1>:...:<attrn>, comma-separated ex.:\n    // func1:1:attr1:attr2:attr3, func2:2:attr3:attr4\n    attribute_mappings: function() {\n        return  \"virt_limit:1:virt_limit\";\n    },\n\n    pre_virt_limit: function() {\n    },\n\n    post_virt_limit: function() {\n        if (!standalone && consumer.isManifest()) {\n            var virt_limit = attributes.get(\"virt_limit\");\n            if (!'unlimited'.equals(virt_limit)) {\n                // As we have unbound an entitlement from a physical pool that was previously\n                //   exported, we need to add back the reduced bonus pool quantity.\n                var virt_quantity = parseInt(virt_limit) * entitlement.getQuantity();\n                if (virt_quantity > 0) {\n                    var pools = post.lookupBySubscriptionId(pool.getSubscriptionId());\n                    for (var idex = 0 ; idex < pools.size(); idex++ ) {\n                        var derivedPool = pools.get(idex);\n                        if (derivedPool.getAttributeValue(\"pool_derived\")) {\n                            post.updatePoolQuantity(derivedPool, virt_quantity);\n                        }\n                    }\n                }\n            }\n            else {\n                // As we have unbound an entitlement from a physical pool that was previously\n                //   exported, we need to set the unlimited bonus pool quantity to -1.\n                var pools = post.lookupBySubscriptionId(pool.getSubscriptionId());\n                for (var idex = 0 ; idex < pools.size(); idex++ ) {\n                    var derivedPool = pools.get(idex);\n                    if (derivedPool.getAttributeValue(\"pool_derived\")) {\n                        if(derivedPool.getQuantity() == 0) {\n                            post.setPoolQuantity(derivedPool, -1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"
}]}